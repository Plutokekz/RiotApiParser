import json
import os
from datetime import date, datetime

from main import CONVERT, get_api_endpoints, parse_apis

CONVERT.update({
    'string': 'string',
    'int': 'integer',
    'long': 'long',
    'float': 'float',
    'boolean': 'boolean'
})

TYPES = {
    "string": "char *",
    "integer": "int",
    "boolean": "bool"
}


# TODO: generate functions for endpoints
# TODO: refactor Parser

class Parser:

    def __init__(self):
        self._import_std_bool = False

    def parse_ref(self, property):
        if t := property.get("$ref"):
            return f'{t.split("/")[-1]}*'
        return None

    def parse_type(self, type_):
        pass

    def parse_property(self, name, property):
        if "type" in property.keys():
            type_ = property.get('type')
            if type_ == 'array':
                type_ = f"{self.parse_array(property['items'])}*"
        elif "$ref" in property.keys():
            type_ = self.parse_ref(property)

        tt = TYPES.get(type_)
        type_ = type_ if tt is None else tt
        if type_ == 'bool':
            self._import_std_bool = True
        if d := property.get('description'):
            return f"    //{d}\n    {type_} {name};\n"
        return f"    {type_} {name};\n"

    def parse_array(self, items):
        for item in items:
            if 'type' in item.keys():
                tt = TYPES.get(item['type'])
                type_ = item['type'] if tt is None else tt
                return type_
            elif '$ref' in item.keys():
                return self.parse_ref(item)

    def parse_to_c(self, name, properties):
        struct_properties = "".join([self.parse_property(name, property) for name, property in properties.items()])
        return f"struct {name} {{\n{struct_properties}\n}};\n"

    def parse_definition(self, name, definition):
        return self.parse_to_c(name, definition['properties'])

    def parse_definitions(self, definitions):
        typedefs, structs = [], []
        for name, definition in definitions.items():
            structs.append(self.parse_definition(name, definition))
            typedefs.append(f"typedef struct {name} {name};\n")
        return typedefs, structs

    def parse_schema(self, schema):
        name = schema['title']
        structs = [self.parse_to_c(name, schema['properties'])]
        typedefs = [f"typedef struct {name} {name};\n"]
        if 'definitions' in schema.keys():
            t, s = self.parse_definitions(schema['definitions'])
            structs += s
            typedefs += t
        return name, "".join(typedefs), "".join(structs)

    def parse_file(self, filepath):
        with open(filepath, "r") as fp:
            file = json.load(fp)
            return self.parse_schema(file)

    def parse_directory(self, dir):
        for file in os.listdir(dir):
            yield self.parse_file(os.path.join(dir, file))

    def create_path(self, path):
        dirs = path.split(os.sep)
        path = ""
        for dir in dirs:
            path = os.path.join(path, dir)
            if not os.path.exists(path):
                os.makedirs(path)

    def write_header_file(self, path, typedefs, structs):
        print(path)
        with open(path, "w") as fp:
            fp.write("/*\n")
            fp.write(" * Generated by RiotApiParser\n")
            fp.write(f" * from {path.split(os.sep)[-1][:-1]}json\n")
            fp.write(f" * {datetime.now()}\n")
            fp.write("*/\n\n")
            if self._import_std_bool:
                fp.write("#include <stdbool.h>\n")
                fp.write("\n\n")
            fp.write(typedefs)
            fp.write("\n\n")
            fp.write(structs)

    def generate(self, json_path, header_path):
        self.create_path(header_path)
        for model in os.listdir(json_path):
            for name, typedefs, structs in self.parse_directory(os.path.join(json_path, model)):
                dir = os.path.join(header_path, model)
                self.create_path(dir)
                self.write_header_file(os.path.join(dir, f"{name}.h"), typedefs, structs)
                self._import_std_bool = False


if __name__ == "__main__":
    parser = Parser()
    parser.generate("c/models", "c/generated")
